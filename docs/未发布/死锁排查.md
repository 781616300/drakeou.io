## 死锁排查

首先观察线上生产环境是否异常

`jps -l`查看全部进程

找到当前程序进程号

`jstack`+进程号 查看运行状态

```java
===================================================
"Thread-1":
        at com.baidu.ai.aip.auth.MyThread.run(DeadLockDemo.java:39)
        - waiting to lock <0x00000000d6105060> (a java.lang.String)
        - locked <0x00000000d6105098> (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)
"Thread-0":
        at com.baidu.ai.aip.auth.MyThread.run(DeadLockDemo.java:39)
        - waiting to lock <0x00000000d6105098> (a java.lang.String)
        - locked <0x00000000d6105060> (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```



## 对可重入锁的理解

在一段synchronized代码中，调用了另外一个被synchronized修饰的方法，因为是同一个线程，所以不用等待锁（否则不就自己把自己死锁了）。所以也可以锁当是同一个线程来获取锁时，可以直接获取。

又或者说在同步方法存在嵌套时，只用获取第一把锁。

ReentrantLock是一样的，要注意锁是配对的。



## AQS（底层中的底层，核心中的核心）

所有锁的lock操作都是AQS实现。

内部类Node构成的队列

对队列的操作都是CAS

AQS和BlockingQueue的区别：

AQS就是所有的锁，而BlockingQueue是线程池中用于缓存任务的

AQS控制的是线程，而BlockingQueue控制的是对象