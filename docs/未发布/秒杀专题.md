## 秒杀专题

观察从客户端请求访问到服务器，整个过程经历了 从服务器网关->代码（Service层）->数据库

根据木桶理论，整个访问的速度取决于**系统中响应速度最慢的地方**。而访问数据库是**内存对磁盘进行IO**，是系统中效率速度最低的地方，同时数据库所支持的QPS也是最小的，所有系统在大并发时数据库是最容易崩溃的。

因此所有对并发秒杀的优化核心在于**如何减少全部请求直接对数据库的访问**，全部思路和技术也是围绕此展开

优化思路如下：

1. 将数据放到Redis中，也就是放到内存中，提高查询的效率，而不去直接访问DB，对于已经秒杀完的产品可以直接全部返回。绝大部分秒杀失败的请求都被Redis挡住，快速做了处理。
2. 使用MQ，将Redis放进处理程序的请求进行异步处理，直接对用户进行返回而不等待同步处理完成。提高了对用户的响应速度，实际体感优化其实不大，因为到实际处理的代码还是同步在操作数据库（创建订单，减库存）。
   1. MQ中是如何把任务交给MQ的Recevier去做的，那么显然要把Service层的代码和处理数据一起传过去，MQ里面应该是不能直接传递对象（Service）的。对象的本质是一段代码，代码本质就是字符串，没有特定的编译器代码就不能运行，所以在传递时将对象变成字符串传递，取出来还是在Java环境下就仍然可以使用。
3. 前端的缓存，页面缓存，减少对服务器的请求

### 数据库设计

表：

- 商品表
- 秒杀商品表（与商品之间做外键依赖）
- 订单表

### 使用socket连接redis

我们使用的绝大部分服务，redis，mysql等等都是web service。因为这些**程序**运行时希望给**其他程序**提供服务，那么程序和程序之间必然需要通信，所以其实**提供服务**是**进程间通信**的问题。因为有时需要给其他机器提供服务，要跨越物理机在网络上提供服务，而且观察连接redis,mysql时需要提供**IP+端口号**也暗示了，这些服务的基础都是**socket**!!!

使用socket连接上之后就可以按照**服务规定的方式**进行操作使用了（也就是规定的语法），而Java对Mysql和Redis的封装都是在Socket基础之上的。

关于语法的思考：

最近学习东西喜欢思考原理，原来不太注意一笔带过的细节总会让人深思。代码到底是什么，程序又是什么。首先我觉得需要划分出讨论特定一段代码的界限，因为Java代码在JVM眼里才有意义而对于C++编译器而言就是一段没有意义的**字符串**，这也说明的编程的本质，**按照特定的规则去说特定的话**，**符合约定的内容才有意义**，所以也可以说**代码就是字符串**在运行时被编译器编译放到CPU中运行才成为了程序，而同样对于编译器和CPU而言他们的基础也在于**约定**，也就是逻辑上大家都认为他是什么，那么他就是什么。

### 把所有可以缓存的东西缓存起来

- 用户登录：用户第一次登录是携带账号，密码进行登录的，必须要查询一次数据库。第一次之后就用`token`存到用户`cookie`中进行登录，但是这个`token`如果写到DB中那么之后的登录即使是检查`token`登陆也要访问DB，这就是需要避免的。所以可以将**用户对象存储起来**，（使用JSON提供的功能，对象可以被序列化也可以通过字节码反序列化变成对象），那么之后用户再登录直接通过`token`就能在`redis`中找到用户对象进行使用
- 秒杀商品的库存信息：显然每次秒杀后库存是减少了的，但不应该立即就去`MySQL`中进行修改，那样又会直接访问DB，这些信息同样也是缓存在`redis`中。
- 秒杀商品的订单信息：用户秒杀之后生成了对应的订单用来组织用户再次秒杀，那么显然成功秒杀的订单应该存在于`redis`中。
- 秒杀是否已经结束：正常来说用户每次访问都会先去`redis`中查询库存尝试减库存，但是考虑到`redis`也是通过网络提供服务（他快因为他在内存中运行全部数据），所以对于**秒杀是否还在进行**这种信息（不需要入库的信息）可以直接放在本地内存中（**使用内存标记**）其实就是使用一个数据结构存储**特定商品的秒杀状态**。（这点其实可以看到数据库的本质只是提供特定的服务，放在自己内存和`redis`的区别只是是否可以直接获取）

### SpringBoot相关

`@Controller`,`@Service`,`@Repository`和`@Bean`有什么不同？

在Spring的Bean空间管理中，上面应该都是以对象形式存在，但是一般前三个注解作用的是业务类，比较复杂内部会存在对其他对象的依赖，而Bean作用在方法上，一般不存在依赖。可能这就是区别

### 单机优化思路

1. 增加redis缓存，在Redis中减库存。所有请求都会过redis，只有成功减库存的才会进行MySQL。减少了 **除秒杀成功之外的请求**，增加了**全部请求对Redis的访问**。
2. 使用**内存标记**，在库存已经减完的情况下不再去访问Redis，请求redis也算网络开销了，内存中就是JVM可以直接访问到，速度最快。只有在内存标记**被置为售完之前**的请求，（瞬间并发冲进来的那一部分请求）会访问redis，修改完内存标记后，剩下的请求不会访问redis了。
3. 使用MQ提升用户体验。首先MQ将创建订单和MySQL中真实减库存的操作去异步处理，但是这一步**是没有提升效率的**，因为原本即使并发去执行操作MySQL，也是线程安全的（而且因为Redis保证了进来的线程均是秒杀成功的线程）而且是**串行执行的**，放到MQ中仍然是**串行执行**（执行的线程数也一样）。但是区别在于整个串行执行过程中，所有秒杀到商品的线程是在**阻塞等待去操作MySQL**（操作同一行的会阻塞，也就是减库存），客户端的请求也就阻塞了，而异步可以马上给用户一个反馈，并让客户端再进行定时来请求结果（结果是存在Redis中的）。那么这样，**原本阻塞到减库存和创建订单全部成功的长请求**，被分割成了**两段**，第一次请求可以快速响应，第二段是连续多段的**缓存访问**，**阻塞DB**->**快速响应**，**查询结果**（redis），（DB服务被MQ去执行了）.