## 未解之谜

前言：Spring的事务控制不是线程安全的。

```java
@Service
public class SecKillServiceImpl implements SecKillService {

    @Autowired
    SecKillMapper mapper;

    @Transactional
    @Override
    public void SecKillProduct(String productId) {
        //查询剩余库存
        Product product1 = mapper.queryProduceById(productId);
        if(product1.getStock()<=0){
            throw new RuntimeException("商品已售完");
        }
        mapper.CreateOrder(product1.getProductId(), UUID.randomUUID().toString().substring(0, 25));
        mapper.SecKillProduct(product1.getProductId());
//        if(mapper.queryProduceById(productId).getStock()<0){
//            throw new RuntimeException("商品已售完");
//        }
    }
}
```

如果在多线程环境下运行如上代码显然是不安全的，因为可能多个线程在**数据库连接池**还有剩余的情况下**几乎同时**去判断**库存的值**，并进行修改，最后都成功提交，而导致**多卖了不存在的东西**。

同时，在并发数量足够大时，**多卖出的数量**和**连接池最大值**及**tomcat最大连接数**也有诡异的关系。

> 在tomcat采用默认最大连接数（8192springboot中），而最大连接池设置为100

连接池设置：

![最大连接池100](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414120627299.png)

开启1000的并发数量，并循环10次。

![Jmeter设置并发](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414120547776.png)

最终结果：

- 库存变为-99，并且测试多次都是-99。如果把连接池改成50，就会是-49.

  ![最终库存](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414120934021.png)

- 生成了199个订单（起始共100库存）

![image-20200414121104890](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414121104890.png)

> 如果设置tomcat最大连接数小于连接池数量，那么最终的错误数量就取决于tomcat的连接数

修改tomcat结果和上面一样。也就是最终错误的数量取决于tomcat，数据库连接池数量较小的一个。

**Tomcat**, **Service**, **连接池**

### 为什么数量正好是最大连接数-1

可以想象，在并发足够大的情况下，所有连接池都应该**充分被利用**。也就是**单一时间内**所有连接池都有**事务**在上面操作，此时其中一个**事务**完成了操作，并写到了数据库中，那么进来一个**新的事务**，此时**连接池**中存在`1个`新事务和`49个`旧的事务（假设连接池数量是50）。如果完成的那个事务操作的恰好是最后一个库存，那么**剩下**的`49个`事务操作的就是不存在的库存，而**新的事务**因为库存已经为0不会成功操作。

> 改成如下方式，就不会出现错误操作的事务

```java
@Service
public class SecKillServiceImpl implements SecKillService {

    @Autowired
    SecKillMapper mapper;

    @Transactional
    @Override
    public void SecKillProduct(String productId) {
        //查询剩余库存
        Product product1 = mapper.queryProduceById(productId);
        if(product1.getStock()<=0){
            throw new RuntimeException("商品已售完");
        }
        mapper.CreateOrder(product1.getProductId(), UUID.randomUUID().toString().substring(0, 25));
        mapper.SecKillProduct(product1.getProductId());			//1
        if(mapper.queryProduceById(productId).getStock()<0){	//2
            throw new RuntimeException("商品已售完");
        }
    }
}
```

但是为什么呢？

如果事务在程序中不是串行执行的，就应该存在可能多个事务**在创建完订单后同时第二次检测库存**，然后**进入到提交阶段**，也就是在库存为1时应该可能出现结果不正确的**事务**，然而尝试了相当多次，结果一直是正确的。。。

因为`MySQL`中写数据是要加行锁的，也就是`mapper.SecKillProduct(product1.getProductId());`在多个线程间其实是阻塞的，在等待行锁的释放才可以去减库存。也就是在语句1处造成了类似串行执行的效果，每个得到锁的线程都从1开始运行一个完整的时间片（足以保证可以运行完这个方法），那么并发中所有线程就是串行通过1，2语句的也就不会出现错误的事务。



当然基于**行锁**的想法，可以直接在`MySQL`的执行语句修改成判断`stock`是否大于0，如果否则会直接错误，就不用在service层中判断了。