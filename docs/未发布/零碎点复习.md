## 零碎点复习

1. cookie和session
   1. session的session id是存在cookie中的
   2. 两个加在一起才能解决Http无状态的问题
   3. cookie为了保证安全是不可以跨域的（url中的"."数量不同就不是一个域名）
   4. session是可以跨域的，如果不同的域名是一个服务器，那服务器肯定可以通过session id 查找到
   5. cookie禁用，就会导致session id不能发送。所以可以session id附在url之后
2. mysql的可重复读是怎么实现的（MVCC）
   - Multi-Version Concurrency Control ，多版本并发控制
   - 不同事务可以对同一行数据同时更改，不加锁
   - 每行（条）数据都有两个隐藏列，`tri_id`和`roll_pointer`，分别记录操作这条数据的事务id和指向版本链下一个数据的指针
   - 写是可以同时进行的，只要保证读取是正确的，就不存在安全性的问题
   - 所以当进行`select`时，**可重复读**和**读已提交**会根据当前**还未提交的事务**创建一个事务id的记录表`m_ids`（也叫生成了ReadView）
   - 读取操作就会从对应行最新的数据开始尝试
     1. 如果该数据事务id小于当前`m_ids`中的最小id就可以读取这条（表示该数据对应的最新事务早就提交了）
     2. 如果事务id在`m_ids`范围内，但没有对应的记录，也可以读取（表示事务在中间发生，但已经提交了，可以读）
     3. 如果事务id大于，那一定不可以读（表示最新的事务比`m_ids`记录还要新）
     4. 不能读的情况就顺着版本链向下寻找
   - 以上就确保了未提交的事务是被检查了的，对应的修改不会被读取到（读未提交被干掉了）
   - 而**读已提交**和**可重复读**的区别就在于生成ReadView时机不同
     - **读已提交**每次`select`都会生成m_ids，也就确保了读取的都是提交的数据，但是两次读取之间就可能会不一致了
     - **可重复读**只有第一次`select`会生成ReadView，多次读取时记录的事务id都是一样的，那么多次读取也就能读到相同的值

