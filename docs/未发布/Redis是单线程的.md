> Redis是单线程的

- 多线程一定比单线程慢（线程间的切换，用户态到核心态）
- 高性能服务器不一定都是多线程的

Redis是将全部的数据都加载到内存中，CPU不是Redis的性能瓶颈，内存和网络传输才是。多次读写都在同一个CPU上操作，不变动反而是最快的



> Redis命令操作

Redis的数据结构是不直接接触的，所有命令操作的都是Key和Value，也就是区分不同数据类型要使用不同的命令。（始终注意key不是变量名，不代表一个对象，也就没有结构之说，只是一个键）



> Redis操作总结

**抽取共性**

| String   |            |
| -------- | ---------- |
| set      | get        |
| keys     | 查看键     |
| exists   | 判断键存在 |
| append   | 尾添加     |
| strlen   | 计算长度   |
| incr(by) | decr(by)   |
| getrange | setrange   |
| mset     | mget       |





> Redis事务

一次性，顺序性，排他性

事务是不保证原子性的，如果取货multi和exec之间数据被修改了，事务不会有任何影响，实际在exec语句才开始执行，所有也就是看先后顺序。

- 编译型异常

也就是代码有问题，事务exec()就直接错误，一行语句也不会执行

- 运行时错误

代码没有问题，但是操作时出错。仅错误的语句无法执行，正确的语句可以正常执行（**这里看的出来事务并没有原子性**）



> 使用watch可以实现乐观锁

watch监视对象后，如果key的version发生变化，那么后续的事务就会失败。



有个问题：单个线程中开启multi后，不能再普通操作Redis的，必须将事务执行或者放弃，软件层面已经保证了线程安全。但是因为事务不是原子性操作，那么如果另外一个线程在事务执行瞬间也操作了事务中的key该怎么办？

答：这正是Redis事务不是原子性会导致的线程安全问题，所以jedis是一种BIO的模式（Jedis是直连Redis的）。而lettuce是通过netty实现的（NIO的模式）。

对比

- Jedis多个线程直连，那么保证线程安全同一时间只有一个可以操作，相当于IO阻塞
- lettuce只有一个线程，使用消息队列处理Redis操作请求，同一时间只有一个线程





班号-学号-姓名

1. 论文（word or PDF）
2. 录音的PPT
3. 评价表，最好纸质
4. 格式 注意空格

